# Database
DATABASE_URL=postgresql+asyncpg://tripplanner:tripplanner@localhost:5433/tripplanner

# LLM Provider Selection
# Options: "ionet" (default) or "anthropic"
LLM_PROVIDER=ionet

# IO Intelligence (io.net) - OpenAI-compatible API
# Get your API key from: https://io.net
IONET_API_KEY=io-v2-eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6ImQ3ZGNmMDBhLTk3NDItNGY1Mi1hMTQzLTEwZDY2MTIyYWIyZCIsImV4cCI6NDkxOTg1ODQ4OH0.ntyR9PHCMkuFVIT6OL7G1z_C4SISZBcnEqbg6tMO6jqEROonIgkn7Jozte1QWjPI3Z2KwGHontzsYJ8e2lVBBA
IONET_BASE_URL=https://api.intelligence.io.solutions/api/v1/

# Model configuration for io.net
# Trip Chat: mistralai/Mistral-Nemo-Instruct-2407 (cheap, fast)
# Macro Planning: meta-llama/Llama-3.3-70B-Instruct (strong reasoning)
# NOTE: Model names must include vendor prefix (e.g., mistralai/, meta-llama/)
TRIP_CHAT_MODEL=mistralai/Mistral-Nemo-Instruct-2407
TRIP_PLANNING_MODEL=meta-llama/Llama-3.3-70B-Instruct

# LLM-based POI Selection (experimental)
# When enabled, uses LLM to select/re-rank POI candidates after deterministic filtering
# The LLM can ONLY choose from candidates already filtered by city/radius/category
# Set to true to enable, false (default) to use deterministic ranking only
USE_LLM_FOR_POI_SELECTION=true
# Model for POI selection (leave empty to use TRIP_PLANNING_MODEL)
POI_SELECTION_MODEL=
# Maximum candidates to send to LLM (cost control)
POI_SELECTION_MAX_CANDIDATES=15

# Anthropic Claude (alternative provider)
# Uncomment and set LLM_PROVIDER=anthropic to use
# ANTHROPIC_API_KEY=your_anthropic_api_key_here
# ANTHROPIC_BASE_URL=https://api.anthropic.com
# ANTHROPIC_MODEL=claude-3-5-sonnet-20241022
# TRIP_CHAT_MODEL=claude-3-5-haiku-20241022
# TRIP_PLANNING_MODEL=claude-3-5-sonnet-20241022

# Google Maps Platform
# Get your API key from: https://console.cloud.google.com/apis/credentials
# Enable "Places API" and "Routes API" in your Google Cloud project
GOOGLE_MAPS_API_KEY=AIzaSyA9zQL4vUkvjU2v_EflycOlAj6v8XBnk5c

# Google Places API (for POI search)
GOOGLE_PLACES_BASE_URL=https://maps.googleapis.com/maps/api/place/textsearch/json
GOOGLE_PLACES_DEFAULT_LANGUAGE=en
GOOGLE_PLACES_DEFAULT_RADIUS_METERS=50000
GOOGLE_PLACES_TIMEOUT_SECONDS=10

# Google Routes API (for travel time/distance)
GOOGLE_ROUTES_BASE_URL=https://routes.googleapis.com/directions/v2:computeRoutes
GOOGLE_ROUTES_TIMEOUT_SECONDS=10

# Travel Time Provider Selection
# Options: "simple" (heuristic, default) or "google_maps" (real Google Routes API)
TRAVEL_TIME_PROVIDER=google_maps


# =============================================================================
# Geo-Adequate Routing Settings
# =============================================================================

# Hotel Anchor: Bias first blocks of day toward hotel location
# When enabled, POIs closer to the hotel are preferred for morning activities
HOTEL_ANCHOR_ENABLED=true
# Number of first blocks per day to apply hotel proximity bias
HOTEL_ANCHOR_BLOCKS=2
# Weight for distance penalty: effective_score = rank_score - weight * distance_km
# Higher values = stronger preference for nearby POIs
HOTEL_ANCHOR_DISTANCE_WEIGHT=0.5

# Daily Route Optimization: Reorder blocks within a day to minimize travel
# This reorders flexible activity blocks to reduce total travel time
ENABLE_DAILY_ROUTE_OPTIMIZATION=true
# Maximum cluster size for permutation search (keep <= 5 to avoid factorial explosion)
MAX_OPTIMIZATION_BLOCKS_PER_CLUSTER=5

# Max Per-Hop Travel Time: Limit long travel between consecutive POIs
# When exceeded, the optimizer tries to find a closer alternative POI
ENABLE_TRAVEL_HOP_LIMIT=true
# Maximum allowed travel time in minutes between consecutive POIs
MAX_TRAVEL_MINUTES_PER_HOP=40

# =============================================================================
# Smart District-Based Routing (NEW - optimizes walking routes by neighborhoods)
# =============================================================================

# Enable smart routing with geographic clustering
# When enabled, POIs are grouped into districts and routes stay within neighborhoods
# This significantly reduces "zigzag" routes across the city
ENABLE_SMART_ROUTING=true

# Use LLM for district planning (vs deterministic fallback)
# LLM assigns districts to time blocks for more intelligent routing
# Fallback uses nearest-neighbor heuristic (faster, no LLM cost)
USE_LLM_FOR_DISTRICT_PLANNING=true

# Grid cell size for geographic clustering (in km)
# Larger values = fewer, bigger districts; Smaller = more granular
CLUSTER_CELL_SIZE_KM=1.5

# Minimum POIs required to form a standalone district
# Smaller clusters are merged with neighbors
MIN_POIS_PER_DISTRICT=5

# Maximum number of districts per city
# Excess districts are merged to prevent over-fragmentation
MAX_DISTRICTS_PER_CITY=8

# Minimum POI rating for smart routing selection
# Only POIs with rating >= this value are considered (quality filter)
SMART_ROUTING_MIN_RATING=4.5

# Minimum candidates needed per block; triggers expansion if fewer
# When district has fewer candidates, expands search to nearby districts
DISTRICT_POI_MIN_CANDIDATES=3

# Factor to expand search when insufficient candidates
# 2.0 = double the search radius if needed
DISTRICT_POI_EXPANSION_FACTOR=2.0

# =============================================================================
# Authentication & Freemium Gating
# =============================================================================

# Enable freemium restrictions (requires auth for full access)
# When true: guests see only Day 1, limited to 1 trip generation
# When false: all features available without auth (for development/testing)
FREEMIUM_ENABLED=false

# Maximum trips a guest can generate before requiring auth
GUEST_MAX_TRIPS=1

# JWT Configuration (change in production!)
JWT_SECRET_KEY=CHANGE_ME_IN_PRODUCTION_USE_SECURE_RANDOM_STRING
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=30

GOOGLE_CLOUD_PROJECT_ID=gemini-cli-483409

# Server
HOST=0.0.0.0
PORT=8000
DEBUG=true